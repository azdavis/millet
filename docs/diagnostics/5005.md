# 5005

Typechecking failed, because of "circularity". This means we attempted to take a type variable $\alpha$, and set it equal to a type $\tau$, where that type $\tau$ contains the original type variable $\alpha$ itself.

Consider this example:

```sml
fun f x = x x
(**       ^ circular type: `?a` occurs in `?a -> ?b` *)
```

When typechecking `f`, Millet does the following:

1. Conjure up a new type variable that is the type of the value variable `x`. Let's call it `?x`.
2. Enter the body of `f` to see how `x` is used. By looking at how `x` is used, we can understand what `x`'s type, aka `?x`, should be.

Entering the body of `f`, we see the entire body of `f` is an application expression: `x x`, the application of `x` to itself.

In `x x`, the first occurrence of `x` treats `x` like a function being applied to an argument. So it must have a type like `?a -> ?b`, where `?a` and `?b` are type variables. So, we have that `?x = ?a -> ?b`.

The second occurrence of `x` treats `x` as the argument to that function, which we just said has type `?a -> ?b`. So we have `?x = ?a`, the type of the argument to the function.

We now have:

- `?x = ?a -> ?b`
- `?x = ?a`

By transitivity, we have `?a = ?a -> ?b`.

That is, we are setting a type variable, in this case `?a`, to a type, in this case `?a -> ?b`, that contains itself. This is not allowed.
