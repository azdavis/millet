# 5005

Typechecking failed, because of "circularity", which means we attempted to a set a type variable to be equal to a type containing that type variable itself.

Consider this example:

```sml
fun f x = x x
(**       ^ circular type: `'a` occurs in `'a -> 'b` *)
```

When typechecking `f`, Millet does the following:

1. Conjure up a fresh, unconstrained type variable for the name `x`. Let's use `'x` as the type variable for `x`.
2. Enter the body of `f` to see how `x` is used, noting constraints on `'x` as we go.

Entering the body of `f`, we see the entire body is one application expression: `x x`, the application of `x` to itself.

- `x` is used as a function, so it must have a type like `'a -> 'b` where `'a` and `'b` are types. So, we have that `'x = 'a -> 'b`.
- Further, `x` is used as the argument to a function, which we just said has type `'a -> 'b`. So we have `'x = 'a`, the type of the argument to the function.

We now have

- `'x = 'a -> 'b`
- `'x = 'a`

Substituting, we have `'a = 'a -> 'b`. That is, we are setting a type variable, in this case `'a`, to a type, in this case `'a -> 'b`, that contains itself. This is not allowed.
