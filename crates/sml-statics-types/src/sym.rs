//! `Sym`s, aka symbols, aka type names, aka generated types. And exceptions.

#![allow(clippy::module_name_repetitions)]

use crate::info::{TyInfo, ValEnv};
use crate::ty::{Ty, TyKind, TyScheme};
use crate::{def, overload};
use drop_bomb::DropBomb;
use std::fmt;

/// A symbol, aka a type name. Definition: `TyName`
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Sym(idx::Idx);

impl fmt::Debug for Sym {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let mut dt = f.debug_tuple("Sym");
    match self.primitive() {
      None => dt.field(&self.0),
      Some(x) => dt.field(&x.as_str()),
    };
    dt.finish()
  }
}

macro_rules! mk_special_syms {
  ($( ($idx:expr, $mk_ty:ident, $name:ident, $prim:path), )*) => {
    impl Sym {
      $(
        #[allow(missing_docs)]
        pub const $name: Self = Self(idx::Idx::new_u32($idx));
      )*

      #[doc = "Returns the primitive kind for this sym."]
      #[must_use]
      pub fn primitive(&self) -> Option<def::PrimitiveKind> {
        let s = match *self {
          $(
            Self::$name => $prim,
          )*
          _ => return None,
        };
        Some(s)
      }
    }

    impl Ty {
      $(
        mk_special_syms!(@mk_ty, $mk_ty, $name, $idx);
      )*
    }
  };
  (@mk_ty, y, $name:ident, $idx:expr) => {
    #[allow(missing_docs)]
    pub const $name: Self = Self { kind: TyKind::Con, idx: idx::Idx::new_u32($idx) };
  };
  (@mk_ty, n, $name:ident, $idx:expr) => {};
}

// @sync(special_sym_order)
mk_special_syms![
  (0, y, EXN, def::PrimitiveKind::Exn),
  (1, y, INT, def::PrimitiveKind::Int),
  (2, y, WORD, def::PrimitiveKind::Word),
  (3, y, REAL, def::PrimitiveKind::Real),
  (4, y, CHAR, def::PrimitiveKind::Char),
  (5, y, STRING, def::PrimitiveKind::String),
  (6, y, BOOL, def::PrimitiveKind::Bool),
  (7, n, LIST, def::PrimitiveKind::List),
  (8, n, REF, def::PrimitiveKind::RefTy),
];

impl Sym {
  /// there's only 1, and it's EXN.
  const NUM_WEIRD: usize = 1;

  /// never call this on a weird sym.
  fn idx(self) -> usize {
    self.0.to_usize() - Self::NUM_WEIRD
  }

  /// Returns whether this `Sym` was generated by a [`Syms`] after that `Syms` generated the
  /// `marker`.
  #[must_use]
  pub fn generated_after(self, marker: SymsMarker) -> bool {
    self != Self::EXN && self.idx() >= marker.0
  }
}

/// An exception.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Exn(idx::Idx);

/// Whether this `Sym` admits equality.
#[derive(Debug, Clone, Copy)]
pub enum Equality {
  /// It always does, regardless of whether the type arguments do.
  Always,
  /// It does if and only if the type arguments do.
  Sometimes,
  /// It never does, regardless of whether the type arguments do.
  Never,
}

/// Information about a `Sym`.
#[derive(Debug, Clone)]
pub struct SymInfo {
  /// The path this sym was defined at.
  pub path: sml_path::Path,
  /// The ty info for the sym.
  pub ty_info: TyInfo,
  /// How this sym admits equality.
  pub equality: Equality,
}

/// Information about an `Exn`.
#[derive(Debug, Clone)]
pub struct ExnInfo {
  /// The path the exn was declared at.
  pub path: sml_path::Path,
  /// The parameter type for this exception.
  pub param: Option<Ty>,
}

/// Information about overloads.
#[derive(Debug, Default, Clone)]
#[allow(missing_docs)]
pub struct Overloads {
  pub int: Vec<Sym>,
  pub real: Vec<Sym>,
  pub word: Vec<Sym>,
  pub string: Vec<Sym>,
  pub char: Vec<Sym>,
}

impl std::ops::Index<overload::Basic> for Overloads {
  type Output = Vec<Sym>;

  fn index(&self, index: overload::Basic) -> &Self::Output {
    match index {
      overload::Basic::Int => &self.int,
      overload::Basic::Real => &self.real,
      overload::Basic::Word => &self.word,
      overload::Basic::String => &self.string,
      overload::Basic::Char => &self.char,
    }
  }
}

impl std::ops::IndexMut<overload::Basic> for Overloads {
  fn index_mut(&mut self, index: overload::Basic) -> &mut Self::Output {
    match index {
      overload::Basic::Int => &mut self.int,
      overload::Basic::Real => &mut self.real,
      overload::Basic::Word => &mut self.word,
      overload::Basic::String => &mut self.string,
      overload::Basic::Char => &mut self.char,
    }
  }
}

/// Information about generated types, generated exceptions, and overload types.
///
/// Note the `Default` impl is "fake", in that it returns a totally empty `Syms`, which will lack
/// even built-in items like `type int` and `exception Bind`.
#[derive(Debug, Default, Clone)]
pub struct Syms {
  /// always use Sym::idx to index
  syms: Vec<SymInfo>,
  exns: Vec<ExnInfo>,
  overloads: Overloads,
}

impl Syms {
  /// Start constructing a `Sym`.
  pub fn start(&mut self, path: sml_path::Path) -> StartedSym {
    let ty_info = TyInfo {
      ty_scheme: TyScheme::zero(Ty::NONE),
      val_env: ValEnv::default(),
      def: None,
      disallow: None,
    };
    // must start with sometimes equality, as an assumption for constructing datatypes. we may
    // realize that it should actually be never equality based on arguments to constructors.
    self.syms.push(SymInfo { path, ty_info, equality: Equality::Sometimes });
    StartedSym {
      bomb: DropBomb::new("must be passed to Syms::finish"),
      // calculate len after push, because we sub 1 in get, because of Sym::EXN.
      sym: Sym(idx::Idx::new(self.syms.len())),
    }
  }

  /// Finish constructing a `Sym`.
  pub fn finish(&mut self, mut started: StartedSym, ty_info: TyInfo, equality: Equality) {
    started.bomb.defuse();
    let sym_info = &mut self.syms[started.sym.idx()];
    sym_info.ty_info = ty_info;
    sym_info.equality = equality;
  }

  /// Returns `None` if and only if passed `Sym::EXN`.
  ///
  /// # Panics
  ///
  /// If the sym didn't exist. (Probably a different `Syms` generated it).
  #[must_use]
  pub fn get(&self, sym: Sym) -> Option<&SymInfo> {
    if sym == Sym::EXN {
      return None;
    }
    Some(self.syms.get(sym.idx()).unwrap())
  }

  /// Inserts a new exception.
  pub fn insert_exn(&mut self, path: sml_path::Path, param: Option<Ty>) -> Exn {
    let ret = Exn(idx::Idx::new(self.exns.len()));
    self.exns.push(ExnInfo { path, param });
    ret
  }

  /// Gets information about an exception.
  ///
  /// # Panics
  ///
  /// If the exn didn't exist. (Probably a different `Syms` generated it).
  #[must_use]
  pub fn get_exn(&self, exn: Exn) -> &ExnInfo {
    self.exns.get(exn.0.to_usize()).unwrap()
  }

  /// Return a marker, so we may later whether a `Sym` has been generated after this marker.
  pub fn mark(&self) -> SymsMarker {
    SymsMarker(self.syms.len())
  }

  /// Iterate over the `Syms`'s info.
  pub fn iter_syms(&self) -> impl Iterator<Item = &SymInfo> {
    self.syms.iter()
  }

  /// Returns the overloads.
  pub(crate) fn overloads(&self) -> &Overloads {
    &self.overloads
  }

  /// Returns the mutable overloads.
  pub fn overloads_mut(&mut self) -> &mut Overloads {
    &mut self.overloads
  }
}

/// A marker to determine when a `Sym` was generated.
#[must_use]
#[derive(Debug, Clone, Copy)]
pub struct SymsMarker(usize);

/// A helper to construct information about [`Syms`]s.
#[must_use]
#[derive(Debug)]
pub struct StartedSym {
  bomb: DropBomb,
  sym: Sym,
}

impl StartedSym {
  /// Returns the sym that this marker represents.
  #[must_use]
  pub fn sym(&self) -> Sym {
    self.sym
  }
}
