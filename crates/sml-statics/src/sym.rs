//! `Sym`s, aka symbols, aka type names, aka generated types.

use crate::types::{Ty, TyInfo, TyScheme, ValEnv};
use crate::{def, overload};
use drop_bomb::DropBomb;
use std::fmt;

/// Definition: `TyName`
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub(crate) struct Sym(idx::Idx);

impl fmt::Debug for Sym {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let mut dt = f.debug_tuple("Sym");
    match self.primitive() {
      None => dt.field(&self.0),
      Some(x) => dt.field(&x.as_str()),
    };
    dt.finish()
  }
}

macro_rules! mk_special_syms {
  ($( ($idx:expr, $mk_ty:ident, $name:ident, $prim:path), )*) => {
    impl Sym {
      $(
        pub(crate) const $name: Self = Self(idx::Idx::new_u32($idx));
      )*

      pub(crate) fn primitive(&self) -> Option<def::PrimitiveKind> {
        let s = match *self {
          $(
            Self::$name => $prim,
          )*
          _ => return None,
        };
        Some(s)
      }
    }

    impl Ty {
      $(
        mk_special_syms!(@mk_ty, $mk_ty, $name, $idx);
      )*
    }
  };
  (@mk_ty, y, $name:ident, $idx:expr) => {
    pub(crate) const $name: Ty = Ty::zero(Sym::$name);
  };
  (@mk_ty, n, $name:ident, $idx:expr) => {};
}

// @sync(special_sym_order)
mk_special_syms![
  (0, y, EXN, def::PrimitiveKind::Exn),
  (1, y, INT, def::PrimitiveKind::Int),
  (2, y, WORD, def::PrimitiveKind::Word),
  (3, y, REAL, def::PrimitiveKind::Real),
  (4, y, CHAR, def::PrimitiveKind::Char),
  (5, y, STRING, def::PrimitiveKind::String),
  (6, y, BOOL, def::PrimitiveKind::Bool),
  (7, n, LIST, def::PrimitiveKind::List),
  (8, n, REF, def::PrimitiveKind::RefTy),
];

impl Sym {
  /// there's only 1, and it's EXN.
  const NUM_WEIRD: usize = 1;

  /// never call this on a weird sym.
  fn idx(self) -> usize {
    self.0.to_usize() - Self::NUM_WEIRD
  }

  /// Returns whether this `Sym` was generated by a [`Syms`] after that `Syms` generated the
  /// `marker`.
  pub(crate) fn generated_after(self, marker: SymsMarker) -> bool {
    self != Self::EXN && self.idx() >= marker.0
  }
}

#[derive(Debug, Clone, Copy)]
pub(crate) enum Equality {
  Always,
  Sometimes,
  Never,
}

#[derive(Debug, Clone)]
pub(crate) struct SymInfo {
  pub(crate) path: sml_path::Path,
  pub(crate) ty_info: TyInfo,
  pub(crate) equality: Equality,
}

#[derive(Debug, Clone)]
pub(crate) struct ExnInfo {
  pub(crate) path: sml_path::Path,
  pub(crate) param: Option<Ty>,
}

/// Information about generated types, generated exceptions, and overload types.
///
/// Note the `Default` impl is "fake", in that it returns a totally empty `Syms`, which will lack
/// even built-in items like `type int` and `exception Bind`.
#[derive(Debug, Default, Clone)]
pub struct Syms {
  /// always use Sym::idx to index
  syms: Vec<SymInfo>,
  exns: Vec<ExnInfo>,
  overloads: Overloads,
}

impl Syms {
  pub(crate) fn start(&mut self, path: sml_path::Path) -> StartedSym {
    let ty_info = TyInfo {
      ty_scheme: TyScheme::zero(Ty::None),
      val_env: ValEnv::default(),
      def: None,
      disallow: None,
    };
    // must start with sometimes equality, as an assumption for constructing datatypes. we may
    // realize that it should actually be never equality based on arguments to constructors.
    self.syms.push(SymInfo { path, ty_info, equality: Equality::Sometimes });
    StartedSym {
      bomb: DropBomb::new("must be passed to Syms::finish"),
      // calculate len after push, because we sub 1 in get, because of Sym::EXN.
      sym: Sym(idx::Idx::new(self.syms.len())),
    }
  }

  pub(crate) fn finish(&mut self, mut started: StartedSym, ty_info: TyInfo, equality: Equality) {
    started.bomb.defuse();
    let sym_info = &mut self.syms[started.sym.idx()];
    sym_info.ty_info = ty_info;
    sym_info.equality = equality;
  }

  /// Returns `None` iff passed `Sym::EXN`.
  pub(crate) fn get(&self, sym: Sym) -> Option<&SymInfo> {
    if sym == Sym::EXN {
      return None;
    }
    self.syms.get(sym.idx())
  }

  pub(crate) fn insert_exn(&mut self, path: sml_path::Path, param: Option<Ty>) -> Exn {
    let ret = Exn(idx::Idx::new(self.exns.len()));
    self.exns.push(ExnInfo { path, param });
    ret
  }

  pub(crate) fn get_exn(&self, exn: Exn) -> &ExnInfo {
    self.exns.get(exn.0.to_usize()).unwrap()
  }

  pub(crate) fn mark(&self) -> SymsMarker {
    SymsMarker(self.syms.len())
  }

  pub(crate) fn iter_syms(&self) -> impl Iterator<Item = &SymInfo> {
    self.syms.iter()
  }

  pub(crate) fn overloads(&self) -> &Overloads {
    &self.overloads
  }

  pub(crate) fn overloads_mut(&mut self) -> &mut Overloads {
    &mut self.overloads
  }
}

/// Information about overloads.
#[derive(Debug, Default, Clone)]
pub(crate) struct Overloads {
  pub(crate) int: Vec<Sym>,
  pub(crate) real: Vec<Sym>,
  pub(crate) word: Vec<Sym>,
  pub(crate) string: Vec<Sym>,
  pub(crate) char: Vec<Sym>,
}

impl std::ops::Index<overload::Basic> for Overloads {
  type Output = Vec<Sym>;

  fn index(&self, index: overload::Basic) -> &Self::Output {
    match index {
      overload::Basic::Int => &self.int,
      overload::Basic::Real => &self.real,
      overload::Basic::Word => &self.word,
      overload::Basic::String => &self.string,
      overload::Basic::Char => &self.char,
    }
  }
}

impl std::ops::IndexMut<overload::Basic> for Overloads {
  fn index_mut(&mut self, index: overload::Basic) -> &mut Self::Output {
    match index {
      overload::Basic::Int => &mut self.int,
      overload::Basic::Real => &mut self.real,
      overload::Basic::Word => &mut self.word,
      overload::Basic::String => &mut self.string,
      overload::Basic::Char => &mut self.char,
    }
  }
}
/// A marker to determine when a `Sym` was generated.
#[derive(Debug, Clone, Copy)]
pub(crate) struct SymsMarker(usize);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub(crate) struct Exn(idx::Idx);

/// A helper to construct information about [`Syms`]s.
pub(crate) struct StartedSym {
  bomb: DropBomb,
  sym: Sym,
}

impl StartedSym {
  pub(crate) fn sym(&self) -> Sym {
    self.sym
  }
}
